I"ڬ<p>This blog article talks about the intuition behind activation functions which form an integral part in the design of Neural Net (NN for short) architectures.</p>

<p>By the end of this article you will learn:</p>
<ul>
  <li>What is a spiking neuron?</li>
  <li>How to simulate a Leaky Integrate and Fire neuron (- a spiking neuron model)?</li>
  <li>What is the intuition behind activation functions?</li>
</ul>

<p>It is going to be a bit lengthy read; hence, please have some time available. This article is intended for folks interested in Computational Neuroscience and connectionist AI.
Familiarity with neuroscience topics is not a prerequisite here. I have tried to write this article as lucid as possible.</p>

<h1 id="introduction">Introduction</h1>
<p>Ever wondered why do we have activation functions in the NNs? Well… the most common (and correct) answer is to introduce non-linearity in the network model, which helps in representing and computing non-linear functions. The absence of activation functions in NNs would effectively equate the network model to a matrix multiplication of weights and inputs. Thus, reducing the network to compute only Linear Transformations. In this article, I will delve deeper into the theory behind activation functions. And as this article’s title goes, I will start with a spiking neuron model and then gradually build the intuition behind activation functions e.g. ReLU, Sigmoid, etc. in an artificial neuron.</p>

<p>You might be wondering…, what is a Spiking Neuron? Unsurprisingly, Spiking Neurons are neuron models which generate or fire action potentials (aka spikes) upon receiving an input current (or so-called stimulus); unlike artificial neurons in NNs which produce a continuous numerical output after feeding the summation of weighted inputs and bias into an activation function \(\phi()\) (shown in the picture below).</p>

<center><img src="artificial_neuron.jpg" alt="artificial_neuron" width="600" />
<figcaption>Artificial Neuron - Example model credit: <a href="https://www.scielo.br/scielo.php?pid=S2179-10742017000300628&amp;script=sci_arttext">Oliveira et al.</a></figcaption></center>

<p>In the upcoming sections, I will briefly introduce spiking neurons, followed by describing the mathematical model of Leaky Integrate and Fire (LIF) neurons. Next, I will simulate a LIF neuron and then develop the intuition behind activation functions.</p>

<h1 id="spiking-neurons">Spiking Neurons</h1>

<p>Adding to the description above, spiking neurons are mathematical abstractions of biological neurons that mimic their physiological behavior more realistically than artificial neurons. To learn about spiking neurons let us start by understanding the action potentials.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Action Potentials are waves of the membrane's potential difference (between the intracellular and extracellular environment) propagating through the neuron's axon.</code></p>
</blockquote>

<p>Physiologically, a biological neuron fires action potentials upon receiving a stimulus. This stimulus can be a sensory input from the environment or even an incoming action potential. In the absence of stimulus, the neuron generally rests at a <code class="language-plaintext highlighter-rouge">resting potential</code> which is around \(-70\) millivolt (\(mV\)). However, each time a neuron receives a stimulus its membrane potential rises. But, does this rise in membrane potential necessarily mean that an action potential has been generated? No. To better understand this let us get a bird’s eye view of the membrane potential dynamics in the picture below. Please note that the numerals mentioned in the picture do not reflect the actual measurements of neuron’s biophysical values. Also, there are no sharp edges in the actual waveform.</p>

<center><img src="SN_MP.png" alt="SN_MP" width="600" /><figcaption>Membrane Potential Dynamics - Picture credit: <a href="https://www.jstage.jst.go.jp/article/softscis/2006/0/2006_0_207/_pdf">Alnajjar et al.</a></figcaption></center>

<p>The <code class="language-plaintext highlighter-rouge">y-axis</code> denotes the membrane potential and the <code class="language-plaintext highlighter-rouge">x-axis</code> denotes the time in milliseconds. The first upward arrow denotes an incoming action potential (or spike), and this results in the rise of membrane potential. Each incoming spike increases the neuron’s membrane potential, and it is only when its membrane potential reaches a certain threshold (say \(V_{th}\), generally around \(-55mV\)), it fires an action potential. In the above picture the threshold (\(V_{th}\)) is denoted by value \(0.1\). As you can see, immediately after firing an action potential (the smaller left-pointing arrow at the top) the neuron’s membrane potential falls below \(0\) and it enters into a so-called <code class="language-plaintext highlighter-rouge">refractory</code> state (the bigger left-pointing arrow at the bottom).</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">During the refractory period a neuron cannot fire another spike; unless and until it receives a stimulus much stronger than a required normal.</code></p>
</blockquote>

<p>The refractory period in biological neurons generally lasts for \(2ms\) to \(4ms\) of time. In the above picture, the refractory period is shown to last for around \(6ms\). Note that once the refractory period is over, the neuron is ready to spike again!</p>

<p>If a Spiking Neuron produces \(50\) spikes in a second, we say that it is firing (or spiking) at a frequency of \(50Hz\). Thus, a Spiking Neuron has a minimum firing rate (generally at or above \(0Hz\)) and a maximum firing rate (generally below \(150Hz\)). There are many <a href="https://en.wikipedia.org/wiki/Biological_neuron_model">spiking neuron models</a>, e.g. Integrate and Fire model, Leaky Integrate and Fire model, Exponential Integrate and Fire model, etc. Here, I will simulate a Leaky Integrate and Fire (LIF) neuron model, but with some assumptions. I will assume that the neuron is unable to fire during the refractory period no matter what the input stimulus is. Also, I will discard the units of assumed physiological values (e.g. membrane potential \(V\)) because this is a qualitative simulation, and it doesn’t affect the overall understanding or behavior of the spiking neurons. By the way, I am choosing the LIF neuron model because of its excellent trade-off between simplicity and ability to mimic the neuronal dynamics.</p>

<h2 id="leaky-integrate-and-fire-lif-neuron">Leaky Integrate and Fire (LIF) neuron</h2>

<p>The LIF neuron is described by the following <a href="https://neuronaldynamics.epfl.ch/online/Ch1.S3.html">differential equation</a> which governs its membrane potential changes.</p>

\[\frac{dV(t)}{dt} = \frac{V_{rest} - V(t) + RJ(t)}{\tau_{RC}}\]

<p>where \(V(t)\) is the neuron’s membrane potential over time, \(V_{rest}\) is the resting potential, \(R\) is the neuron’s membrane equivalent resistance, \(\tau_{RC}\) is the neuron’s time constant, and \(J(t)\) is the input current over time due to stimulus. The above neuron model is called leaky integrator because it gradually integrates over the membrane potential \(V(t)\); but also leaks it with time via the <code class="language-plaintext highlighter-rouge">leaky</code> resistor \(R\). Also, the above equation resembles to that of a <a href="https://en.wikipedia.org/wiki/Leaky_integrator">Leaky Integrator</a>.</p>

<p>After assuming the values for \(V_{rest}\) and \(R\) to be \(0\) and \(1\) respectively, and addition of the equation which describes the behavior of membrane potential when it reaches the threshold, the LIF neuron (to be simulated next) is described as follows.</p>

\[\frac{dV(t)}{dt} = \frac{J(t) - V(t)}{\tau_{RC}}  \quad \quad \text{ when } V(t) &lt; V_{th}\]

\[V(t) \leftarrow 0 \quad \quad  \quad \quad \text{ when } V(t) &gt; V_{th} \text{ for } t_{th} &lt; t &lt; t_{th} + \tau_{ref}\]

<p>where \(t_{th}\) is the time point when the neuron’s membrane potential reaches \(V_{th}\), and \(\tau_{ref}\) is the above-mentioned refractory period in \(ms\).</p>

<h2 id="simulation-details-of-lif-neuron">Simulation details of LIF neuron</h2>

<p>The above equations are exactly what I will simulate here. I will be using the Euler method to solve the differential equation \(\frac{dV(t)}{dt}\). As mentioned above, I am assuming values for certain parameters in the equations; all of which are mentioned in the table below. Note that I have also discarded the units.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Parameter</th>
      <th style="text-align: center">Description</th>
      <th style="text-align: center">Assumed Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">\(R\)</td>
      <td style="text-align: center">Membrane Resistance</td>
      <td style="text-align: center">\(1\)</td>
    </tr>
    <tr>
      <td style="text-align: center">\(V_{th}\)</td>
      <td style="text-align: center">Threshold Potential</td>
      <td style="text-align: center">\(1\)</td>
    </tr>
    <tr>
      <td style="text-align: center">\(V_{rest}\)</td>
      <td style="text-align: center">Resting Potential</td>
      <td style="text-align: center">\(0\)</td>
    </tr>
    <tr>
      <td style="text-align: center">\(\tau_{RC}\)</td>
      <td style="text-align: center">Membrane Time Constant</td>
      <td style="text-align: center">\(0.02\)</td>
    </tr>
    <tr>
      <td style="text-align: center">\(\tau_{ref}\)</td>
      <td style="text-align: center">Neuron’s Refractory Period</td>
      <td style="text-align: center">\(0.002\)</td>
    </tr>
  </tbody>
</table>

<p>By the way, one more computational detail needs to be mentioned here. The biophysical change in a neuron’s dynamics takes over continuous time. However, since we are computationally simulating the neuron, we have to deal with discrete time intervals. Therefore, I will be setting the timestep \(dt\) to \(0.001s\).</p>

<h1 id="code-for-simulating-lif-neuron">Code for simulating LIF neuron</h1>
<p>Let us first begin by implementing the Euler’s method to get the neuron’s membrane potential at every time point. Note that for all the spiking neuron’s simulations below, the <code class="language-plaintext highlighter-rouge">stimulus</code> input current \(J\) is fed continuously throughout the simulation duration.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_new_membrane_potential</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">v_prev</span><span class="p">,</span> <span class="n">tau_RC</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
  <span class="sh">"""</span><span class="s">
  Implements Euler method to solve the differential equation to obtain membrane
  potential.

  Args:
    J (float): The input current.
    v_prev (float): The previous membrane potential.
    tau_RC (float): The membrane</span><span class="sh">'</span><span class="s">s time constant.
    dt (float): The discrete timestep of the simulation.

  Returns:
    float: The new membrane potential.
  </span><span class="sh">"""</span>
  <span class="n">slope</span> <span class="o">=</span> <span class="nf">float</span><span class="p">((</span><span class="n">J</span> <span class="o">-</span> <span class="n">v_prev</span><span class="p">))</span><span class="o">/</span><span class="n">tau_RC</span>
  <span class="k">return</span> <span class="n">v_prev</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">slope</span>
</code></pre></div></div>

<p>Next, let us implement the LIF neuron model. Note that during the refractory period, the neuron’s membrane potential is set to the resting potential <code class="language-plaintext highlighter-rouge">v_rest</code> i.e. \(0\) to indicate no increase in potential; thus, no spiking during the refractory period. Also, if the neuron’s membrane potential ever goes below \(0\), it is reset to resting potential.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">simulate_spiking_neuron</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">tau_RC</span><span class="o">=</span><span class="mf">20e-3</span><span class="p">,</span> <span class="n">tau_ref</span><span class="o">=</span><span class="mf">2e-3</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
  <span class="sh">"""</span><span class="s">
  Simulates a spiking neuron.

  Args:
    J (float): The input current.
    tau_RC (float): The membrane</span><span class="sh">'</span><span class="s">s time constant.
    tar_ref (float): The neuron</span><span class="sh">'</span><span class="s">s refractory period (no spike in this duration).
    T (float): The total time of the simulation.
    dt (float): The discrete timestep of the simulation.

  Returns:
    int, [float], [float]: Number of spikes, Time points at which there was a
                           spike, Membrane potential at all time points.
  </span><span class="sh">"""</span>
  <span class="c1"># Assumptions.
</span>  <span class="n">v_rest</span><span class="p">,</span> <span class="n">v_th</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>

  <span class="n">spike_times</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Stores the time points when the neuron spikes.
</span>  <span class="n">v</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Stores the neuron's membrane potential at each time point.
</span>  <span class="n">time_point</span><span class="p">,</span> <span class="n">num_spikes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
  <span class="c1"># At the start of simulation, i.e. before the execution of first time point
</span>  <span class="c1"># it is assumed that the membrane's previous potential is at `v_rest`.
</span>  <span class="n">v_prev</span> <span class="o">=</span> <span class="n">v_rest</span>

  <span class="nf">while</span><span class="p">(</span><span class="n">time_point</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">):</span>
    <span class="n">v_curr</span> <span class="o">=</span> <span class="nf">get_new_membrane_potential</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">v_prev</span><span class="p">,</span> <span class="n">tau_RC</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>

    <span class="c1"># If `v_curr` &gt;= `v_th` at the current time point, the neuron spikes.
</span>    <span class="k">if</span> <span class="n">v_curr</span> <span class="o">&gt;=</span> <span class="n">v_th</span><span class="p">:</span>
      <span class="n">num_spikes</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">spike_times</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">time_point</span><span class="p">)</span>
      <span class="n">v</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">v_curr</span><span class="p">)</span>

      <span class="c1"># Set the neuron's state in refractory period, starting at the time when
</span>      <span class="c1"># the spike ocurred.
</span>      <span class="nf">while</span><span class="p">(</span><span class="n">time_point</span> <span class="o">&lt;</span> <span class="n">spike_times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">tau_ref</span><span class="p">):</span>
        <span class="c1"># Rounding to 3 floating places is necessary to avoid precision issues.
</span>        <span class="n">time_point</span> <span class="o">=</span> <span class="nf">round</span><span class="p">(</span><span class="n">time_point</span> <span class="o">+</span> <span class="n">dt</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_point</span> <span class="o">&gt;=</span> <span class="n">T</span><span class="p">:</span>
          <span class="k">break</span>
        <span class="n">v_curr</span> <span class="o">=</span> <span class="n">v_rest</span> <span class="c1"># Reset the current membrane potential to `v_rest`.
</span>        <span class="n">v</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">v_curr</span><span class="p">)</span>

    <span class="c1"># If `v_curr` goes below `v_rest` at the current time, reset it to `v_rest`.
</span>    <span class="k">elif</span> <span class="n">v_curr</span> <span class="o">&lt;</span> <span class="n">v_rest</span><span class="p">:</span>
      <span class="n">v_curr</span> <span class="o">=</span> <span class="n">v_rest</span>
      <span class="n">v</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">v_curr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">v</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">v_curr</span><span class="p">)</span>

    <span class="n">v_prev</span> <span class="o">=</span> <span class="n">v_curr</span> <span class="c1"># Update the previous membrane potential.
</span>    <span class="n">time_point</span> <span class="o">=</span> <span class="nf">round</span><span class="p">(</span><span class="n">time_point</span> <span class="o">+</span> <span class="n">dt</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># Update the current time.
</span>    <span class="k">if</span> <span class="n">time_point</span> <span class="o">&gt;=</span> <span class="n">T</span><span class="p">:</span>
      <span class="k">break</span>

  <span class="k">return</span> <span class="n">num_spikes</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">,</span> <span class="n">v</span>
</code></pre></div></div>

<p>Now, let us implement a helper function to translate spiking times to spikes, as well as a function to plot them. To mathematically model the spikes, we set it as a Dirac \(\delta\) function at the time of spiking.</p>

\[S_i(t_k) \leftarrow \delta(t_k)\]

<p>where \(t_k\) is the time at which the \(k^{th}\) spike of \(i^{th}\) neuron occurs. \(S_i()\) is simply the spike translation function (from spiking time to spike) of \(i^{th}\) neuron. If you remember, the Dirac \(\delta\) function is zero everywhere except at 0 and its integral over the entire domain is one. Here we model the Dirac \(\delta\) function as simply \(\frac{1}{dt}\) where \(dt\) is the small timestep (here set to \(0.001s\)).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_spike_lines</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
  <span class="sh">"""</span><span class="s">
  Helper function to create spikes.

  Args:
    times ([float]): The simulation time points.
    spike_time ([float]): The simulation time points at which a spike was fired.
    dt (float): The discrete timestep of the simulation.

  Returns:
    [int]: The spike equivalents (delta function).
  </span><span class="sh">"""</span>
  <span class="n">spikes</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">spike_times</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
      <span class="n">spikes</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">dt</span><span class="p">)))</span> <span class="c1"># Delta function approximation.
</span>      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">spikes</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="mi">0</span><span class="o">/</span><span class="n">dt</span><span class="p">)))</span> <span class="c1"># Delta function approximation.
</span>
  <span class="k">return</span> <span class="n">spikes</span>


<span class="k">def</span> <span class="nf">plot_spikes</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">spikes</span> <span class="o">=</span> <span class="nf">get_spike_lines</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nf">int</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">round</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">spikes</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">))</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">spike_times</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">facecolor</span><span class="o">=</span><span class="sh">"</span><span class="s">#00FFFF</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">.</span><span class="nf">suptitle</span><span class="p">(</span><span class="sh">"</span><span class="s">Spike Train for constant input current J = %s, # Spikes: %s</span><span class="sh">"</span>
                 <span class="o">%</span> <span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">spike_times</span><span class="p">)))</span>
    <span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">spikes</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Time $t$ in seconds</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">.</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Spike</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<p>What about plotting neuron’s membrane potential \(V(t)\)? Let us plot it too for a better understanding.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">plot_potential</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
  <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
  <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">facecolor</span><span class="o">=</span><span class="sh">"</span><span class="s">#00FFFF</span><span class="sh">"</span><span class="p">)</span>
  <span class="n">ax</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="n">fig</span><span class="p">.</span><span class="nf">suptitle</span><span class="p">(</span><span class="sh">"</span><span class="s">Membrane potential over the simuation duration T = %s, J: %s</span><span class="sh">"</span>
               <span class="o">%</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">J</span><span class="p">))</span>
  <span class="n">ax</span><span class="p">.</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Time $t$ in seconds</span><span class="sh">"</span><span class="p">)</span>
  <span class="n">ax</span><span class="p">.</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Membrane potential</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="experiments">Experiments</h1>
<p>We have implemented all the necessary pieces of code. Let us next import the necessary libraries for simulation and call the above-defined functions.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="k">def</span> <span class="nf">simulate_exp</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
  <span class="sh">"""</span><span class="s">
  Simulates experiment.

  Args:
    J (float): Input current.
    T (float): Simulation time period in seconds.
    dt (float): Simulation timestep in seconds.
  </span><span class="sh">"""</span>
  <span class="n">num_spikes</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="nf">simulate_spiking_neuron</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
  <span class="nf">plot_spikes</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">spike_times</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
  <span class="nf">plot_potential</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
</code></pre></div></div>

<p>Let us feed an input current of \(0\) and observe the behaviour.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">simulate_exp</span><span class="p">(</span><span class="n">J</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<center><img src="output_12_0.png" alt="output_12_0" width="600" /></center>

<center><img src="output_12_1.png" alt="output_12_1" width="600" /></center>

<p>As expected, there are no spikes and no change in the neuron’s membrane potential (it continues to stay at \(V_{rest} = 0\)). What about feeding an input current of \(1\)?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">simulate_exp</span><span class="p">(</span><span class="n">J</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<center><img src="output_14_0.png" alt="output_14_0" width="600" /></center>

<center><img src="output_14_1.png" alt="output_14_1" width="600" /></center>

<p>Again, no spikes but there was a change in the membrane potential. Visually, it seems that it has reached the threshold \(V_{th} = 1\), but numerically it hasn’t. Let us feed an input current of \(1.1\) and observe.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">simulate_exp</span><span class="p">(</span><span class="n">J</span><span class="o">=</span><span class="mf">1.1</span><span class="p">)</span>
</code></pre></div></div>

<center><img src="output_16_0.png" alt="output_16_0" width="600" /></center>

<center><img src="output_16_1.png" alt="output_16_1" width="600" /></center>

<p>Awesome! We observe the neuron to fire some spikes, a total of \(20\) in number for the input current \(J = 1.1\). Since the simulation duration is \(1s\), the total number of spikes obtained is equal to the firing rate i.e. \(20Hz\). In the above plot, we also see that the membrane potential reaches the threshold \(V_{th} = 1\) after which it immediately falls to \(V_{rest} = 0\) where it remains in the refractory period for \(\tau_{ref} = 0.002\) seconds. The refractory period phenomena would be more visible in the plot below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.001</span>
<span class="n">J</span> <span class="o">=</span> <span class="mf">1.1</span>
<span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="nf">simulate_spiking_neuron</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">)</span>
<span class="nf">plot_potential</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
</code></pre></div></div>

<center><img src="output_18_0.png" alt="output_18_0" width="600" /></center>

<p>As you can see between \(0.04s\) and \(0.06s\), there is a small time period (here \(0.002s\)) where the neuron’s membrane potential remains at \(V_{rest} = 0\), and there is no increase in the membrane potential despite the continuous input stimulus of \(J=1.1\).</p>

<p>You might have guessed that as we would increase the input current, the firing rate would also increase. And yes, it’s true, but partly. After a certain value of input current, the firing rate saturates. In this simulation, it will saturate at \(329Hz\) at an input of \(J=20\) or higher when simulated for \(T = 1s\). I will leave you with why. You will figure it out!</p>

<h1 id="intuition-behind-activation-functions">Intuition behind Activation Functions</h1>
<p>All the above work can now be culminated to get the intuition behind the activation function, the very purpose of this article. As you know, the activation function outputs a value after accepting an input. This input and output is actually an abstract representation of <code class="language-plaintext highlighter-rouge">stimulus</code> and <code class="language-plaintext highlighter-rouge">firing rate</code> respectively. Further simulations will show how. I will feed an input current to the function <code class="language-plaintext highlighter-rouge">simulate_spiking_neuron()</code> for a period of \(1s\) and record the output firing rate. This will be done for each integral input current in the range [\(0\), \(10\)]. Let us write the necessary code for it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">firing_rates</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">input_crnts</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>

<span class="k">for</span> <span class="n">crnt</span> <span class="ow">in</span> <span class="n">input_crnts</span><span class="p">:</span>
  <span class="n">num_spikes</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">simulate_spiking_neuron</span><span class="p">(</span><span class="n">crnt</span><span class="p">)</span>
  <span class="n">firing_rates</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num_spikes</span><span class="p">)</span>
</code></pre></div></div>

<p>Now that we have obtained the firing rates for different input currents, let us plot the firing rate vs the input current graph. Also, let us plot the common activation functions - namely <code class="language-plaintext highlighter-rouge">Sigmoid</code> and <code class="language-plaintext highlighter-rouge">ReLU</code> with the same inputs i.e. the input currents.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">relu</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">plot_firing_rates_and_act_fns</span><span class="p">(</span><span class="n">firing_rates</span><span class="p">,</span> <span class="n">input_crnts</span><span class="p">):</span>
  <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">facecolor</span><span class="o">=</span><span class="sh">"</span><span class="s">#00FFFF</span><span class="sh">"</span><span class="p">)</span>
  <span class="n">fig</span><span class="p">.</span><span class="nf">suptitle</span><span class="p">(</span><span class="sh">"</span><span class="s">Intuition behind Activation Functions</span><span class="sh">"</span><span class="p">)</span>
  <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">plot</span><span class="p">(</span><span class="n">input_crnts</span><span class="p">,</span> <span class="n">firing_rates</span><span class="p">)</span>
  <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Input Current</span><span class="sh">"</span><span class="p">)</span>
  <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Firing Rate in $Hz$</span><span class="sh">"</span><span class="p">)</span>
  <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">"</span><span class="s">Firing Rate vs Input Current</span><span class="sh">"</span><span class="p">)</span>
  <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">plot</span><span class="p">()</span>

  <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">plot</span><span class="p">(</span><span class="n">input_crnts</span><span class="p">,</span> <span class="p">[</span><span class="nf">sigmoid</span><span class="p">(</span><span class="n">crnt</span><span class="p">)</span> <span class="k">for</span> <span class="n">crnt</span> <span class="ow">in</span> <span class="n">input_crnts</span><span class="p">])</span>
  <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Input Current</span><span class="sh">"</span><span class="p">)</span>
  <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Sigmoid Function Output</span><span class="sh">"</span><span class="p">)</span>
  <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">"</span><span class="s">Sigmoid Activation Function</span><span class="sh">"</span><span class="p">)</span>
  <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">plot</span><span class="p">()</span>

  <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nf">plot</span><span class="p">(</span><span class="n">input_crnts</span><span class="p">,</span> <span class="p">[</span><span class="nf">relu</span><span class="p">(</span><span class="n">crnt</span><span class="p">)</span> <span class="k">for</span> <span class="n">crnt</span> <span class="ow">in</span> <span class="n">input_crnts</span><span class="p">])</span>
  <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nf">set_xlabel</span><span class="p">(</span><span class="sh">"</span><span class="s">Input Current</span><span class="sh">"</span><span class="p">)</span>
  <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nf">set_ylabel</span><span class="p">(</span><span class="sh">"</span><span class="s">ReLU Function Output</span><span class="sh">"</span><span class="p">)</span>
  <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">"</span><span class="s">ReLU Activation Function</span><span class="sh">"</span><span class="p">)</span>
  <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nf">plot</span><span class="p">()</span>

<span class="nf">plot_firing_rates_and_act_fns</span><span class="p">(</span><span class="n">firing_rates</span><span class="p">,</span> <span class="n">input_crnts</span><span class="p">)</span>
</code></pre></div></div>

<center><img src="output_23_0.png" alt="output_23_0" width="1000" /></center>

<p>As you can see above, the plot of <code class="language-plaintext highlighter-rouge">Sigmoid Activation Function</code> (although it’s Half Sigmoid due to the non-negative inputs) and the <code class="language-plaintext highlighter-rouge">ReLU Activation Function</code> closely matches the plot of <code class="language-plaintext highlighter-rouge">Firing Rate vs Input Current</code>. And this is exactly what the activation functions represent. Activation Function in NNs is simply a qualitative abstraction of the firing patterns of biological spiking neurons. They qualitatively represent the firing magnitude of neuron upon receiving an input. For example, a step activation function just represents whether a neuron fires or not upon receiving an input. Whereas, a bit complex activation functions like Sigmoid and ReLU actually show the increase in firing rate with the increase in input.</p>

<h1 id="few-closing-words">Few Closing Words</h1>
<p>For the curious mind, feel free to play with the parameters \(\tau_{ref}\), \(\tau_{RC}\) etc. to observe different firing patterns. You will observe that as you decrease the \(\tau_{RC}\) the firing pattern of spiking neuron becomes more like sigmoid and as you increase the \(\tau_{RC}\), the firing pattern becomes more like ReLU. Can you guess what the firing pattern will look like at a sufficiently high value of \(\tau_{RC}\) e.g. at \(\tau_{RC} = 5\)?</p>

<hr />
:ET